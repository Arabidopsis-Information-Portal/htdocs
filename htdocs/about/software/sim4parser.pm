#!/usr/bin/perl

package sim4parser;

# sim4parser.pm - provides routines for parsing sim4 output.
# Lukas Mueller, October 11, 2001.
# Version 0.1

=head1 NAME

B<sim4parser.pm>

=head1 SYNOPSIS

C<use sim4parser;>

C<$parser = sim4parser -E<gt> new("sampleSim4Report.txt");>

C<$besthit = $parser -E<gt> parse();>

C<$parser -E<gt> list ($besthit);>

=head1 DESCRIPTION

The sim4parser module provides functionality to parse the output of sim4 report that were generated using the B<A=0> option. It does not parse output generated by any other sim4 option.

The following function (see below) are currently supported:

C<new()> 

C<parse()> 

C<findBestHit() >

C<neatList() >

C<list()> 

C<getBestScore() >

C<getSecondBestScore()> 

C<getBestIndex() >

C<getSecondBestIndex()> 

C<getNumberOfHits() >

C<getNumberOfExonsInBestHit() >

C<getNumberOfExons() >

C<getIsComplement() >

=head1 VERSION

0.1 (October 18, 2001)

=head1 AUTHOR

Lukas Mueller (mueller@acoma.stanford.edu)

=cut


use strict;

my $debug ="";

1;

=pod

=head1 FUNCTIONS

=cut


=pod

=head2 new()

Creates a new parser object. Parameter: filename of the report to parse. 
Returns a handle to a parsing object.

C<$parser = sim4parser -E<gt> new();>

=cut

# Create a new sim4parser object.
# Parameters: filename
sub new {
  my $class = shift;
  my $self ={};

  $self->{_hits}[0] = ();
  $self->{_currentQuery} = "";
  $self->{_currentSubject} = "";
  $self->{_queryLen} = "";
  $self->{_subjectLen} = "";
  $self->{_match} = 0;
  $self->{_oldQuery} = "";
  $self->{_oldSubject} = "";

  $self->{_filename} = shift;
  return bless $self, $class;

}


=head2 parse()

Parses the parser object generated with new.

C<$parser = sim4parser -E<gt> new("testfile");>

C<$besthit = $parser -E<gt> parse();>

Takes no parameters, returns the internal index of the best hit.

=cut

# Parse the sim4parser object
sub parse {

  my($self) = shift;
 
  my($line) = "";
  my($oldQuery, $currentQuery, $queryLen, $oldQuery, $oldSubject, $currentSubject, $subjectLen) = 0;

  $self -> {_match} = 0;

  open(F, "<$self->{_filename}") || die "Can't open file $self->{_filename}";
  while (<F>) {
    chomp();
    $line = $_;
    
    if ($line =~ /^seq1.\=.(.*)\, (\d+)/) { 
      #output the hits found
      
      $oldQuery = $currentQuery;
      
      
      $currentQuery = $1; 
      $queryLen = $2;
      
      # reset hit array for next iteration
      
      if ($currentQuery ne $oldQuery) { 
	
	# @{$self->{_hits}} = (); 

	
      }  
      $self->{_match}++;
      # The 0th element of each $self{_hits}[$self->{_match}] array will be the query seq id.
      push @{$self->{_hits}[$self->{_match}]}, "$currentQuery, $queryLen";
      
    }
    
    if ($line =~ /seq2 \= (.*)\,.(\d+).bp/) { 
      #print "seq2\n";
      $oldSubject = $currentSubject;
      
      $currentSubject = $1; $subjectLen = $2; 
      
      
      if ($currentSubject ne $oldSubject) {
	my($n) = $self->{_match};
	#	  if (@{$self->{_hits}[$n]}) {  
	# if there are hits we print them out here.
	#print "$currentQuery -- $currentSubject\n";
	#foreach $hit (@{$hits[$match]}) {
	#print "$hit\n";
	#}
      }
      #      $self->{_match}++;
      
      # The 1st element of each $self{_hits}[$self->{_match}] array will be the subject.
      push @{$self->{_hits}[$self->{_match}]}, "$currentSubject, $subjectLen";
    }
    
      
    if ($line =~ /(\d+)\-(\d+).+(\d+)\-(\d+).+(\d+)\%/) {
      push @{$self->{_hits}[$self->{_match}]}, $line;
      #print "pushed $line...\n";
    }
    
    if ($line =~ /complement/i) {
      $self->{_hits}[$self->{_match}][0] .= " \tcomplement";
      
    }
  }
  
  close(F);
  return $self -> findBestHit();
}

=pod

=head2 findBestHit()

Returns the best sim4 hit as an index number to the internal datastructure. This number can be used in other function calls. This is determined by looking at the length of the alignment. The longest alignment wins (over all exons). Note that this can be problematic if matches contain == type matches and are not adjacent on the chromosome. This function is called internally by C<parse()>.

=cut

# Find the best hit 
sub findBestHit {
  my $self = shift;
  
  my($score) = 0;
  my($oldscore) = 0;
  my($i)=0;
  my($first) = 0;
  my($last) = 0; 
  my($bestscore)=0; 
  my($bestindex) = 0;
  my($secondbestscore) = 0;
  my($secondbestindex) = 0;
  
  for ($i=0; $i<scalar(@{$self->{_hits}}); $i++) { # the zero element is empty because
                                                   # of initialization of the hash!
    
    $oldscore = $score;
    
    $self->debug("-----");
    foreach my $h (@{$self->{_hits}[$i]}) { $self -> debug("$h\n"); }
    $self->debug("=====");
    
    $first = $self->{_hits}[$i][2];  # The 0th element is the query seqid!
                                     # The 1st element is the subject seq id!
    $last  = $self->{_hits}[$i][-1]; # -1 is last element
    
        
    $first =~ s/^(\d+)(.*)/$1/;
    #print "first: $first\n";
    $last    =~ s/^(\d+\-)(\d+)(.*)/$2/;
    #print "last: $last\n";
    $score = $last - $first;
    if ($score >= $bestscore) { $secondbestscore = $bestscore; $bestscore = $score; $secondbestindex = $bestindex; $bestindex = $i; }
        
  }
  
  #print "The best match is:\n";
  #foreach my $h (@{$self->{_hits}[$bestindex]}) {
  #  
  #  print "$h\n";
  # }

  $self -> {_bestindex} = $bestindex;
  $self -> {_bestscore} = $bestscore;
  $self -> {_secondbestscore} = $secondbestscore;
  $self -> {_secondbestindex} = $secondbestindex;

  return @{$self->{_hits}[$bestindex]};
  
}

=pod

=head2 neatList()

Takes an index as parameter. Prints the results out as a neat list.

=cut

sub neatList {

  my $self = shift;

  my @results = $self -> findBestHit();

  my @return =();

  foreach my $r (@results) {
    
    if ($r =~ /(\d+)\-(\d+) +\((\d+)\-(\d+)\) +(\d+)\%/) {
      
      my $querystart = $1;
      my $queryend = $2;
      my $subjectstart = $3;
      my $subjectend = $4;
      my $percent = $5;
      my $rest = ""; #$6;

      push @return, "$results[1]\t$querystart\t$queryend\t$subjectstart\t$subjectend\t$percent\t$rest";

    }



  }

  return @return;
}


=head2 list()

C<$parser -E<gt> list($i);>

Lists the match with index $i.

=cut

sub list {
  my $self = shift;
  my $index = shift;

  $self -> debug ("list $index"); 
  
  my @return =();
  
  my @results = @{$self -> {_hits}[$index]};
  
  foreach my $r (@{$self -> {_hits}[$index]}) {

    

    if ($r =~ /(\d+)\-(\d+) +\((\d+)\-(\d+)\) +(\d+)\%(.*)/) {
      
      my $querystart = $1;
      my $queryend = $2;
      my $subjectstart = $3;
      my $subjectend = $4;
      my $percent = $5;
      my $rest = $6;

      push @return, "$results[1]\t$querystart\t$queryend\t$subjectstart\t$subjectend\t$percent\t$rest";

    }

  }
  return @return;
}


=head2 getBestScore()

C<$best = $parser -E<gt> getBestScore(); >

Returns the best Score of the best match. The score is the alignment length in the match. The C<parse()> function has to be called prior to calling this (and any of the following) function(s).

=cut

# returns the best score.
sub getBestScore {
  my $self = shift;
  $self -> debug ("getBestScore ".$self->{_bestscore});
  return $self -> {_bestscore};
}

=head2 getSecondBestScore()

Returns the second best score.

=cut


# returns the score of the second best hit.
sub getSecondBestScore {
  my $self = shift;
  $self -> debug ("getSecondBestScore ".$self->{_secondbestscore});
  return $self -> {_secondbestscore};
}


=head2 getBestIndex()

Returns the internal index of the best hit. This number can then be fed to other functions such as list to output the details of the match.

=cut

# returns the index of the best hit.
sub getBestIndex {
  my $self =shift;
  $self -> debug ("getBestIndex ".$self->{_bestindex});
  return $self -> {_bestindex};
}

=head2 getSecondBestIndex()

Returns the internal index of the second best hit. 

=cut

# Returns the index of the second best hit.
sub getSecondBestIndex {
  my $self = shift;
  $self -> debug ("getSecondIndex ".$self->{_secondbestindex});
  return $self -> {_secondbestindex};
}

=head2 getNumberOfHits()

Returns the number of hits.

=cut

# Returns the total number of hits.
sub getNumberOfHits {
  my $self = shift;
  return scalar(@{$self->{_hits}}-1);
}

=head2 getNumberOfExonsInBestHit()

Returns the number of exons in the best hit.

=cut

# Returns the number of exons in the best hit.
sub getNumberOfExonsInBestHit {
  my $self = shift;
  my $bestindex = $self -> getBestIndex();
  
  return scalar(@{$self->{_hits}[$self->getBestIndex()]}-2);
  
}

=head2 getNumberOfExons()

Returns the number of exons of the match at internal index $i:
C<$exons = $parser -E<gt> getNumberOfExons($i);>

=cut

sub getNumberOfExons {
  my $self = shift;
  my $index = shift;
  
  return scalar(@{$self->{_hits}[$index]}-2);  
}


=head2 getIsComplement()

Checks if the match at index $i is on the forward or reverse strand. The function returns 1 if the hit on the complement strand, 0 otherwise.

C<if ($parser -E<gt> getIsComplement($i)) { doSomething(); }>

=cut

# Returns 1 if the hit is on the complement strand
sub getIsComplement {
  my $self = shift;
  my $index = shift;
  if ($self -> {_hits}[$index][0] =~ /complement/) {
    return 1;
  }
  else {
    return 0;
  }
}

# lists the best two if the second best has a score 
# that is greater than 80% of the best score, otherwise 
# just lists the best hit.

sub outputBestTwo {

  my $self = shift;

  my @a = ();
  my @b = ();

  @a = $self -> list ($self -> getBestIndex());
  
  if (($self -> getBestScore())*0.8 > ($self -> getSecondBestScore())) {
    @b = $self -> list ($self -> getSecondBestIndex());
  }
  
  return @a, @b;
  
}

# isGoodMatch determines if a match is good by the following criteria:
# No == matches are allowed within a gene model.
# No matches below 90% are allowed within a gene model.
# (In both cases, the first and the last exon can have == or less than 90%)
sub isGoodMatch {

  my $self = shift;

  my $index = shift;

  my $taint = "";
  my $i;

  my $exons = $self -> getNumberOfExons($index);


  if ($exons > 1) {

    for ($i=4; $i<scalar(@{$self->{_hits}[$index]}); $i++) {  # 4 is the second exon.
      if ($i != ($exons+1)) {  #don't check the last exon.
	if ($self->{_hits}[$index][$i]=~ /\=\=/) { $taint = "true"; }
	my $percent = $self -> {_hits}[$index][$i];
	$percent =~ s/(.*?)(\d+)(\%.*)/$2/;
	#print "Percent = $percent\n";

	if ($percent < 90) { $taint = "true"; }
      }
    }
  }

  if ($taint) { return 0; }
  else {
    return 1;
  }
  
}


sub debug {
  my $self = shift;
  
  if ($debug) { print "$_[0]\n";}
}
